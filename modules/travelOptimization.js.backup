// modules/travelOptimization.js - Travel time calculation and scheduling optimization
const { getLastAppointment } = require('../outlook');

// Global cache for travel time calculations
const travelTimeCache = new Map();
let lastBookedJobLocation = null; // Will be dynamically determined
let locationInitialized = false;

/**
 * Initialize the starting location from the most recent appointment
 * This should be called at system startup or when needed
 */
async function initializeStartingLocation(accessToken = null) {
  if (locationInitialized && lastBookedJobLocation) {
    return lastBookedJobLocation;
  }
  
  try {
    if (accessToken) {
      const lastAppointment = await getLastAppointment(accessToken, new Date());
      if (lastAppointment && lastAppointment.location) {
        lastBookedJobLocation = lastAppointment.location;
        locationInitialized = true;
        console.log(`üè† Initialized starting location from calendar: ${lastBookedJobLocation}`);
        return lastBookedJobLocation;
      }
    }
  } catch (error) {
    console.log('‚ö†Ô∏è Could not initialize from calendar:', error.message);
  }
  
  // Fallback to Brisbane CBD
  lastBookedJobLocation = 'Brisbane CBD, QLD 4000, Australia';
  locationInitialized = true;
  console.log(`üè† Using default starting location: ${lastBookedJobLocation}`);
  return lastBookedJobLocation;
}

/**
 * Calculate travel time using OpenAI API as fallback
 * This provides intelligent estimates when Google Maps API is unavailable
 */
async function calculateTravelTimeWithOpenAI(origin, destination) {
  try {
    // Check if OpenAI API key is available
    if (!process.env.OPENAI_API_KEY) {
      console.log('ü§ñ OpenAI API key not configured');
      return null;
    }

    const { OpenAI } = require('openai');
    const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

    const prompt = `Calculate the driving travel time between these two locations in Brisbane, Australia:

Origin: ${origin}
Destination: ${destination}

Consider:
- Current time and typical Brisbane traffic patterns
- Most likely driving route
- Distance and road types
- Brisbane's urban layout and geography

Provide only the estimated travel time in format "X-Y minutes" (e.g., "15-25 minutes").
If locations are very close (same building/street), respond with "5-10 minutes".
If one location is unclear, make a reasonable Brisbane estimate.

Response format: Just the time range, nothing else.`;

    const response = await openai.chat.completions.create({
      model: "gpt-3.5-turbo",
      messages: [
        {
          role: "system",
          content: "You are a Brisbane travel time expert. Provide accurate driving time estimates between locations in Brisbane, Australia. Always respond with just the time range in 'X-Y minutes' format."
        },
        {
          role: "user",
          content: prompt
        }
      ],
      max_tokens: 50,
      temperature: 0.3
    });

    const travelTime = response.choices[0]?.message?.content?.trim();
    
    if (travelTime && travelTime.includes('minutes')) {
      // Cache the OpenAI result for 30 minutes
      const cacheKey = `${origin}->${destination}`;
      travelTimeCache.set(cacheKey, {
        duration: travelTime,
        timestamp: Date.now(),
        source: 'openai'
      });
      
      return travelTime;
    }

    console.log('ü§ñ OpenAI response format invalid:', travelTime);
    return null;

  } catch (error) {
    console.log('ü§ñ OpenAI travel calculation failed:', error.message);
    return null;
  }
}

async function calculateTravelTime(origin, destination, accessToken = null) {
  // Ensure we have a proper origin
  if (!origin || origin === 'null' || origin === 'undefined') {
    origin = await initializeStartingLocation(accessToken);
  }
  
  // Ensure destination is valid
  if (!destination || typeof destination !== 'string') {
    console.log('‚ö†Ô∏è Invalid destination for travel time calculation');
    return '20-30 minutes';
  }
  
  const cacheKey = `${origin}->${destination}`;
  
  // Check cache first
  if (travelTimeCache.has(cacheKey)) {
    const cached = travelTimeCache.get(cacheKey);
    if (Date.now() - cached.timestamp < 3600000) { // 1 hour cache
      console.log('üöó Using cached travel time:', cached.duration);
      return cached.duration;
    }
  }
  
  try {
    // Check if Google Maps API key is available
    if (!process.env.GOOGLE_MAPS_API_KEY || process.env.GOOGLE_MAPS_API_KEY === 'your_google_maps_api_key_here') {
      console.log('üó∫Ô∏è Google Maps API key not configured, trying OpenAI API');
      const openaiTravelTime = await calculateTravelTimeWithOpenAI(origin, destination);
      if (openaiTravelTime) {
        console.log(`ü§ñ Using OpenAI travel estimate: ${openaiTravelTime}`);
        return openaiTravelTime;
      }
      
      console.log('üó∫Ô∏è OpenAI API also unavailable, using Brisbane estimates');
      const fallbackTime = estimateBrisbaneTravelTime(origin, destination);
      console.log(`üöó Using Brisbane geographic estimate: ${fallbackTime}`);
      return fallbackTime;
    }
    
    // Use Google Maps API for accurate travel times
    const response = await fetch(
      `https://maps.googleapis.com/maps/api/distancematrix/json?` +
      `origins=${encodeURIComponent(origin)}&` +
      `destinations=${encodeURIComponent(destination)}&` +
      `mode=driving&` +
      `departure_time=now&` +
      `traffic_model=best_guess&` +
      `key=${process.env.GOOGLE_MAPS_API_KEY}`
    );
    
    const data = await response.json();
    
    // Check for API errors or request denied
    if (data.error_message || data.status === 'REQUEST_DENIED') {
      const errorMsg = data.error_message || 'API request denied';
      console.log(`üó∫Ô∏è Google Maps API error: ${errorMsg}`);
      
      // If it's a billing error or request denied, fall back to OpenAI
      if (errorMsg.includes('billing') || errorMsg.includes('Billing') || data.status === 'REQUEST_DENIED') {
        console.log('üí≥ Google Maps API billing not enabled, trying OpenAI API');
        const openaiTravelTime = await calculateTravelTimeWithOpenAI(origin, destination);
        if (openaiTravelTime) {
          console.log(`ü§ñ Using OpenAI travel estimate: ${openaiTravelTime}`);
          return openaiTravelTime;
        }
        
        console.log('üó∫Ô∏è OpenAI API also failed, using Brisbane estimates');
        const fallbackTime = estimateBrisbaneTravelTime(origin, destination);
        console.log(`üöó Using Brisbane geographic estimate: ${fallbackTime}`);
        return fallbackTime;
      }
      
      throw new Error(`Google Maps API error: ${errorMsg}`);
    }
    
    if (data.status === 'OK' && data.rows[0]?.elements[0]?.status === 'OK') {
      const element = data.rows[0].elements[0];
      const duration = element.duration_in_traffic?.text || element.duration?.text;
      
      // Cache the result
      travelTimeCache.set(cacheKey, {
        duration,
        timestamp: Date.now()
      });
      
      console.log(`üöó Travel time from ${origin} to ${destination}: ${duration}`);
      return duration;
    } else {
      throw new Error(`Google Maps API error: ${data.status}`);
    }
  } catch (error) {
    console.error('Travel time calculation failed:', error);
    
    // Try OpenAI API as first fallback
    try {
      const openaiTravelTime = await calculateTravelTimeWithOpenAI(origin, destination);
      if (openaiTravelTime) {
        console.log(`ü§ñ Using OpenAI fallback travel estimate: ${openaiTravelTime}`);
        return openaiTravelTime;
      }
    } catch (openaiError) {
      console.log('ü§ñ OpenAI API also failed:', openaiError.message);
    }
    
    // Final fallback to Brisbane distance estimates
    const fallbackTime = estimateBrisbaneTravelTime(origin, destination);
    console.log(`üöó Using final fallback travel time: ${fallbackTime}`);
    return fallbackTime;
  }
}

/**
 * Enhanced Brisbane travel time estimation with OpenAI integration
 * This tries OpenAI first, then falls back to geographic estimates
 */
async function estimateBrisbaneTravelTimeEnhanced(origin, destination) {
  try {
    // Try OpenAI first for intelligent analysis
    const openaiTime = await calculateTravelTimeWithOpenAI(origin, destination);
    if (openaiTime && openaiTime.includes('minutes')) {
      console.log(`ü§ñ OpenAI Brisbane estimate: ${openaiTime}`);
      return openaiTime;
    }
  } catch (error) {
    console.log('ü§ñ OpenAI Brisbane estimation failed, using geographic fallback');
  }
  
  // Fallback to basic geographic estimation
  return estimateBrisbaneTravelTime(origin, destination);
}

function estimateBrisbaneTravelTime(origin, destination) {
  // Enhanced fallback based on Brisbane geography
  if (!destination || typeof destination !== 'string') {
    console.log('‚ö†Ô∏è Invalid destination for travel time estimation');
    return '20-30 minutes'; // Default fallback
  }
  
  const destLower = destination.toLowerCase();
  const originLower = (origin || '').toLowerCase();
  
  // Same location check
  if (origin && destination && originLower.includes(destLower.split(',')[0]) || destLower.includes(originLower.split(',')[0])) {
    return '5-10 minutes';
  }
  
  // Brisbane area estimates
  if (destLower.includes('cbd') || destLower.includes('city') || destLower.includes('george street') || destLower.includes('queen street')) {
    return '15-25 minutes';
  } else if (destLower.includes('north') || destLower.includes('chermside') || destLower.includes('albion') || destLower.includes('fortitude valley')) {
    return '20-30 minutes';
  } else if (destLower.includes('south') || destLower.includes('sunnybank') || destLower.includes('logan')) {
    return '25-35 minutes';
  } else if (destLower.includes('west') || destLower.includes('toowong') || destLower.includes('indooroopilly')) {
    return '20-30 minutes';
  } else if (destLower.includes('east') || destLower.includes('carindale') || destLower.includes('wynnum')) {
    return '25-35 minutes';
  } else {
    return '20-30 minutes'; // Default Brisbane estimate
  }
}

async function findMostEfficientSlot(accessToken, customerAddress, issueDescription, priority = 'standard', earliestTime = null) {
  try {
    console.log('üéØ Finding most efficient appointment slot...');
    
    // Always ensure we have the latest starting location
    await initializeStartingLocation(accessToken);
    
    // Set default earliest time if not provided
    if (!earliestTime) {
      earliestTime = new Date();
      earliestTime.setHours(earliestTime.getHours() + 1); // Default to 1 hour from now
    }
    
    // Get the last appointment location for travel optimization and update our tracking
    const lastAppointment = await getLastAppointment(accessToken, earliestTime);
    
    // Automatically update lastBookedJobLocation with the actual last appointment address
    if (lastAppointment && lastAppointment.location) {
      lastBookedJobLocation = lastAppointment.location;
      console.log(`üìç Updated last booked job location to: ${lastBookedJobLocation}`);
    }
    
    const startLocation = lastBookedJobLocation;
    
    console.log(`üìç Starting location: ${startLocation}`);
    console.log(`üìç Customer location: ${customerAddress}`);
    
    // Calculate travel time with access token for proper origin handling
    const travelTime = await calculateTravelTime(startLocation, customerAddress, accessToken);
    const travelMinutes = extractMinutesFromTravelTime(travelTime);
    
    // Calculate service duration based on issue type
    const serviceDuration = calculateServiceDuration(issueDescription);
    
    // Dynamic buffer calculation instead of hardcoded 30 minutes
    const dynamicBuffer = calculateDynamicBuffer(issueDescription, serviceDuration);
    const totalBuffer = dynamicBuffer + travelMinutes + serviceDuration;
    
    console.log(`‚è±Ô∏è Travel time: ${travelTime} (${travelMinutes} minutes)`);
    console.log(`üîß Service duration: ${serviceDuration} minutes`);
    console.log(`üõ°Ô∏è Dynamic buffer: ${dynamicBuffer} minutes`);
    console.log(`‚è∞ Total buffer needed: ${totalBuffer} minutes`);
    
    // Find next available slot with buffer
    const nextSlot = await getNextAvailableSlotWithBuffer(accessToken, totalBuffer, earliestTime, priority);
    
    if (nextSlot) {
      // Update last booked location for next calculation
      updateLastBookedJobLocation(customerAddress);
      console.log(`üìç Setting next starting location to: ${customerAddress}`);
      
      return {
        slot: nextSlot,
        travelTime,
        serviceDuration,
        totalBuffer,
        startLocation
      };
    }
    
    return null;
  } catch (error) {
    console.error('Error finding efficient slot:', error);
    return null;
  }
}

/**
 * Calculate service duration using OpenAI API based on issue description
 * This provides intelligent estimates for plumbing job complexity
 */
async function calculateServiceDurationWithOpenAI(issueDescription = '') {
  try {
    // Check if OpenAI API key is available
    if (!process.env.OPENAI_API_KEY) {
      console.log('ü§ñ OpenAI API key not configured for service duration');
      return null;
    }

    const { OpenAI } = require('openai');
    const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

    const prompt = `Estimate the service duration for this plumbing issue:

Issue: ${issueDescription}

Consider these factors for a professional plumber in Brisbane:
- Job complexity and parts required
- Typical access and setup time
- Testing and cleanup time
- Experience level of professional plumber

Examples:
- Simple drain cleaning: 45-60 minutes
- Toilet installation: 90-120 minutes
- Emergency leak repair: 60-90 minutes
- Hot water system repair: 75-120 minutes
- Tap replacement: 30-45 minutes

Provide only the estimated duration in minutes as a single number (e.g., "75").
Choose the most realistic time for a professional to complete the job properly.`;

    const response = await openai.chat.completions.create({
      model: "gpt-3.5-turbo",
      messages: [
        {
          role: "system",
          content: "You are a professional plumbing expert. Estimate realistic service durations for plumbing jobs in minutes. Always respond with just a number representing minutes."
        },
        {
          role: "user",
          content: prompt
        }
      ],
      max_tokens: 10,
      temperature: 0.2
    });

    const durationStr = response.choices[0]?.message?.content?.trim();
    const duration = parseInt(durationStr);
    
    if (duration && duration > 0 && duration <= 300) { // Reasonable range: 5 minutes to 5 hours
      console.log(`ü§ñ OpenAI service duration: ${duration} minutes for "${issueDescription}"`);
      return duration;
    }

    console.log(`ü§ñ OpenAI service duration invalid: "${durationStr}"`);
    return null;

  } catch (error) {
    console.log(`ü§ñ OpenAI service duration error: ${error.message}`);
    return null;
  }
}

function calculateServiceDuration(issueDescription) {
  if (!issueDescription || typeof issueDescription !== 'string') {
    console.log('‚ö†Ô∏è No issue description provided, using emergency default');
    return 90; // Default for unknown issues - assume complexity
  }
  
  const issue = issueDescription.toLowerCase();
  
  // Emergency/urgent jobs require immediate response and longer resolution time
  if (issue.includes('burst') || issue.includes('flood') || issue.includes('emergency') || 
      issue.includes('water everywhere') || issue.includes('urgent') || issue.includes('leak bad')) {
    console.log('üö® Emergency issue detected, setting duration to 90 minutes');
    return 90; // 1.5 hours for emergencies
  }
  
  // Major installations and replacements
  if (issue.includes('install') || issue.includes('replace') || issue.includes('new') || 
      issue.includes('renovation') || issue.includes('upgrade')) {
    console.log('üîß Installation/replacement detected, setting duration to 120 minutes');
    return 120; // 2 hours for installations
  }
  
  // Hot water system issues typically complex
  if (issue.includes('hot water') || issue.includes('water heater') || issue.includes('boiler') ||
      issue.includes('gas') || issue.includes('electric hot water')) {
    console.log('üî• Hot water system issue detected, setting duration to 75 minutes');
    return 75; // 1.25 hours for hot water
  }
  
  // Drain and pipe blockages
  if (issue.includes('block') || issue.includes('clog') || issue.includes('drain') || 
      issue.includes('slow drain') || issue.includes('backup')) {
    console.log('üö∞ Drain/blockage issue detected, setting duration to 60 minutes');
    return 60; // 1 hour for drain issues
  }
  
  // Simple repairs and maintenance
  if (issue.includes('drip') || issue.includes('minor') || issue.includes('maintenance') || 
      issue.includes('check') || issue.includes('inspect') || issue.includes('small')) {
    console.log('üîß Simple repair/maintenance detected, setting duration to 45 minutes');
    return 45; // 45 minutes for minor work
  }
  
  // Tap and fixture issues
  if (issue.includes('tap') || issue.includes('faucet') || issue.includes('handle') || 
      issue.includes('spout') || issue.includes('fixture')) {
    console.log('üöø Tap/fixture issue detected, setting duration to 50 minutes');
    return 50; // 50 minutes for tap work
  }
  
  // Toilet issues
  if (issue.includes('toilet') || issue.includes('loo') || issue.includes('cistern') || 
      issue.includes('flush')) {
    console.log('üöΩ Toilet issue detected, setting duration to 65 minutes');
    return 65; // Just over 1 hour for toilet work
  }
  
  // Default for general plumbing issues
  console.log('üîß General plumbing issue, setting duration to 70 minutes');
  return 70; // 1 hour 10 minutes for general work
}

/**
 * Enhanced service duration calculation with OpenAI integration
 * This tries OpenAI first, then falls back to rule-based calculation
 */
async function calculateServiceDurationEnhanced(issueDescription) {
  try {
    // Try OpenAI first for intelligent analysis
    const openaiDuration = await calculateServiceDurationWithOpenAI(issueDescription);
    if (openaiDuration && openaiDuration > 0) {
      return openaiDuration;
    }
  } catch (error) {
    console.log('ü§ñ OpenAI service duration failed, using rule-based calculation');
  }
  
  // Fallback to rule-based calculation
  return calculateServiceDuration(issueDescription);
}
  if (issue.includes('hot water') || issue.includes('water heater') || issue.includes('boiler') ||
      issue.includes('gas') || issue.includes('electric hot water')) {
    return 75; // 1.25 hours for hot water systems
  }
  
  // Drain and sewer issues can be complex
  if (issue.includes('drain') || issue.includes('sewer') || issue.includes('blocked') ||
      issue.includes('pipe') || issue.includes('clog')) {
    return 75; // 1.25 hours for drainage issues
  }
  
  // Toilet repairs vary by complexity
  if (issue.includes('toilet')) {
    if (issue.includes('new') || issue.includes('install') || issue.includes('replace')) {
      return 90; // 1.5 hours for toilet replacement
    } else if (issue.includes('repair') || issue.includes('fix') || issue.includes('broken')) {
      return 60; // 1 hour for toilet repairs
    } else {
      return 45; // 45 minutes for simple toilet issues
    }
  }
  
  // Tap/faucet issues usually quicker
  if (issue.includes('tap') || issue.includes('faucet') || issue.includes('drip')) {
    if (issue.includes('new') || issue.includes('install') || issue.includes('replace')) {
      return 60; // 1 hour for tap replacement
    } else {
      return 30; // 30 minutes for tap repairs
    }
  }
  
  // Leak repairs depend on complexity
  if (issue.includes('leak') || issue.includes('leaking')) {
    if (issue.includes('wall') || issue.includes('ceiling') || issue.includes('hidden')) {
      return 90; // 1.5 hours for complex leak detection
    } else {
      return 60; // 1 hour for standard leaks
    }
  }
  
  // Maintenance and inspections
  if (issue.includes('maintenance') || issue.includes('inspection') || issue.includes('check') ||
      issue.includes('service')) {
    return 45; // 45 minutes for maintenance
  }
  
  // Multiple issues mentioned
  const issueCount = (issue.match(/\band\b|\bplus\b|\balso\b|\badditionally\b/g) || []).length;
  if (issueCount > 0) {
    return 90 + (issueCount * 30); // Base 90 min + 30 min per additional issue
  }
  
  // Default for unspecified general plumbing work
  return 60; // 1 hour standard
}

/**
 * Calculate dynamic buffer time based on job complexity
 * @param {string} issueDescription - Description of the plumbing issue
 * @param {number} serviceDuration - Calculated service duration in minutes
 * @returns {number} Buffer time in minutes
 */
function calculateDynamicBuffer(issueDescription = '', serviceDuration = 60) {
  const issue = issueDescription.toLowerCase();
  
  // Base buffer time varies by complexity
  let baseBuffer = 20; // Minimum buffer
  
  if (issue.includes('emergency') || issue.includes('leak') || issue.includes('burst')) {
    baseBuffer = 45; // Emergency jobs need more buffer
  } else if (issue.includes('install') || issue.includes('replacement') || issue.includes('renovation')) {
    baseBuffer = 40; // Installation jobs need extra time
  } else if (issue.includes('repair') || issue.includes('fix')) {
    baseBuffer = 30; // Standard repair buffer
  } else if (issue.includes('maintenance') || issue.includes('inspection')) {
    baseBuffer = 25; // Routine work needs less buffer
  }
  
  // Add complexity-based buffer (10-15% of service duration)
  const complexityBuffer = Math.ceil(serviceDuration * 0.125);
  
  const totalBuffer = baseBuffer + complexityBuffer;
  console.log(`üõ°Ô∏è Dynamic buffer calculation: Base(${baseBuffer}) + Complexity(${complexityBuffer}) = ${totalBuffer} minutes`);
  
  return totalBuffer;
}

function extractMinutesFromTravelTime(travelTimeString) {
  if (!travelTimeString) return 20; // Default
  
  const hourMatch = travelTimeString.match(/(\d+)\s*hour/i);
  const minuteMatch = travelTimeString.match(/(\d+)\s*min/i);
  
  let totalMinutes = 0;
  
  if (hourMatch) {
    totalMinutes += parseInt(hourMatch[1]) * 60;
  }
  
  if (minuteMatch) {
    totalMinutes += parseInt(minuteMatch[1]);
  }
  
  // If no time found, extract from range (e.g., "20-30 minutes")
  if (totalMinutes === 0) {
    const rangeMatch = travelTimeString.match(/(\d+)-(\d+)/);
    if (rangeMatch) {
      totalMinutes = Math.ceil((parseInt(rangeMatch[1]) + parseInt(rangeMatch[2])) / 2);
    }
  }
  
  // Fallback
  return totalMinutes || 20;
}

async function getNextAvailableSlotWithBuffer(accessToken, bufferMinutes, earliestTime = null, priority = 'standard') {
  const { getNextAvailableSlot, isSlotFree } = require('../outlook');
  
  try {
    // For emergency priority, find the very next slot
    if (priority === 'urgent' || priority === 'emergency') {
      const emergencySlot = await getNextAvailableSlot(accessToken, new Date());
      if (emergencySlot) {
        console.log('üö® Emergency slot allocated:', emergencySlot);
        return emergencySlot;
      }
    }
    
    // Calculate the earliest possible start time with buffer
    const now = new Date();
    const bufferTime = new Date(now.getTime() + bufferMinutes * 60000);
    const startTime = earliestTime ? new Date(Math.max(earliestTime.getTime(), bufferTime.getTime())) : bufferTime;
    
    // Round up to next 30-minute slot
    const roundedTime = roundToNextAppointmentSlot(startTime);
    
    console.log(`üïê Looking for slots starting from: ${roundedTime.toLocaleString('en-AU', { timeZone: 'Australia/Brisbane' })}`);
    
    // Get the next available slot
    const slot = await getNextAvailableSlot(accessToken, roundedTime);
    
    if (slot && await isSlotFree(accessToken, slot.start, slot.end)) {
      return slot;
    }
    
    return null;
  } catch (error) {
    console.error('Error getting slot with buffer:', error);
    return null;
  }
}

function roundToNextAppointmentSlot(date) {
  const rounded = new Date(date);
  const minutes = rounded.getMinutes();
  
  // Round to next 30-minute interval
  if (minutes <= 30) {
    rounded.setMinutes(30, 0, 0);
  } else {
    rounded.setHours(rounded.getHours() + 1, 0, 0, 0);
  }
  
  return rounded;
}

/**
 * Update the last booked job location to be used for travel optimization
 * This should be called whenever a new appointment is successfully booked
 */
function updateLastBookedJobLocation(customerAddress) {
  if (customerAddress && typeof customerAddress === 'string') {
    lastBookedJobLocation = customerAddress;
    console.log(`üìç Last booked job location updated to: ${customerAddress}`);
  }
}

/**
 * Get the current last booked job location
 */
function getLastBookedJobLocation() {
  return lastBookedJobLocation;
}

/**
 * Automatically refresh the last booked job location from calendar
 * This can be called periodically or when the system starts
 */
async function refreshLastBookedJobLocation(accessToken) {
  try {
    const lastAppointment = await getLastAppointment(accessToken, new Date());
    if (lastAppointment && lastAppointment.location) {
      lastBookedJobLocation = lastAppointment.location;
      locationInitialized = true;
      console.log(`üîÑ Refreshed last booked job location from calendar: ${lastBookedJobLocation}`);
      return lastBookedJobLocation;
    } else {
      // If no appointments found, ensure we still have a default
      return await initializeStartingLocation(accessToken);
    }
  } catch (error) {
    console.log('‚ö†Ô∏è Could not refresh last booked job location from calendar:', error.message);
    return await initializeStartingLocation(accessToken);
  }
}

module.exports = {
  calculateTravelTime,
  calculateTravelTimeWithOpenAI,
  findMostEfficientSlot,
  calculateServiceDuration,
  calculateServiceDurationWithOpenAI,
  calculateServiceDurationEnhanced,
  extractMinutesFromTravelTime,
  roundToNextAppointmentSlot,
  estimateBrisbaneTravelTime,
  estimateBrisbaneTravelTimeEnhanced,
  updateLastBookedJobLocation,
  getLastBookedJobLocation,
  refreshLastBookedJobLocation,
  initializeStartingLocation,
  calculateDynamicBuffer
};
